/*
Apply rename codemod (CommonJS)
Usage: node scripts/apply-rename-codemod.cjs
Preconditions:
 - Run from repo root
 - Ensure working tree is clean or you are happy with an automatic WIP commit

What it does:
 - Loads .codemod/preview-renames.json (generated by preview script)
 - Renames files on disk (from -> to)
 - Updates static import/require statements across all .ts/.tsx/.js/.jsx files when those imports resolve to renamed files
 - Does NOT modify package.json or other configs

This script is conservative but still non-reversible: commit or stash before running.
*/

const fs = require('fs');
const path = require('path');

const repoRoot = path.resolve(__dirname, '..');
const previewFile = path.join(repoRoot, '.codemod', 'preview-renames.json');
if (!fs.existsSync(previewFile)) {
  console.error('Preview mapping not found at .codemod/preview-renames.json. Run the preview script first.');
  process.exit(1);
}

const mapping = JSON.parse(fs.readFileSync(previewFile, 'utf8'));
if (!Array.isArray(mapping) || mapping.length === 0) {
  console.log('No rename candidates found, exiting.');
  process.exit(0);
}

const extsToTry = ['', '.ts', '.tsx', '.js', '.jsx', '.json'];
const indexSuffixes = ['/index.ts', '/index.tsx', '/index.js', '/index.jsx'];

function walk(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const files = [];
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      if (['node_modules', '.git', '.codemod'].includes(e.name)) continue;
      files.push(...walk(full));
    } else if (e.isFile()) {
      files.push(full);
    }
  }
  return files;
}

function normalizeRel(p) {
  return p.replace(/\\/g, '/');
}

function findMappingForAbs(absPath) {
  const rel = path.relative(repoRoot, absPath).replace(/\\/g, '/');
  return mapping.find((m) => m.from === rel || m.to === rel);
}

function tryResolveImport(fromFile, importPath) {
  // only handle relative imports
  if (!importPath.startsWith('.')) return null;
  const base = path.resolve(path.dirname(fromFile), importPath);
  // if importPath already includes extension, test directly
  for (const ext of extsToTry) {
    const candidate = base + ext;
    if (fs.existsSync(candidate) && fs.statSync(candidate).isFile()) return candidate;
  }
  // try index files
  for (const s of indexSuffixes) {
    const candidate = base + s;
    if (fs.existsSync(candidate) && fs.statSync(candidate).isFile()) return candidate;
  }
  return null;
}

function computeImportPath(fromFile, targetAbs, preserveExtension, originalImport) {
  const rel = path.relative(path.dirname(fromFile), targetAbs).replace(/\\/g, '/');
  let out = rel.startsWith('.') ? rel : './' + rel;
  if (!preserveExtension) {
    // remove extension if present
    out = out.replace(/(\.tsx?|\.jsx?|\.json)$/i, '');
  }
  // Normalize to posix style
  return out;
}

// Build lookup from old absolute path to new absolute path
const oldToNew = new Map();
for (const m of mapping) {
  const oldAbs = path.join(repoRoot, m.from);
  const newAbs = path.join(repoRoot, m.to);
  oldToNew.set(path.normalize(oldAbs), path.normalize(newAbs));
}

console.log('Applying codemod for', mapping.length, 'files');

// 1) Rename files on disk. Create parent dirs for new paths if needed.
for (const [oldAbsNorm, newAbsNorm] of oldToNew.entries()) {
  const oldAbs = oldAbsNorm;
  const newAbs = newAbsNorm;
  if (!fs.existsSync(oldAbs)) {
    console.warn('Skipping missing source file:', oldAbs);
    continue;
  }
  const newDir = path.dirname(newAbs);
  if (!fs.existsSync(newDir)) fs.mkdirSync(newDir, { recursive: true });
  try {
    fs.renameSync(oldAbs, newAbs);
    console.log('Renamed:', path.relative(repoRoot, oldAbs), '→', path.relative(repoRoot, newAbs));
  } catch (err) {
    console.error('Failed to rename', oldAbs, err);
    process.exit(1);
  }
}

// 2) Update import/require statements across files
const allFiles = walk(path.join(repoRoot, 'src'))
  .filter((f) => f.match(/\.(ts|tsx|js|jsx)$/i));

for (const file of allFiles) {
  let content = fs.readFileSync(file, 'utf8');
  let changed = false;
  // regex to find import from '...'
  const importRegex = /(?:from\s+|import\s+\(|require\(|import\s+['"])['"]([^'"\n]+)['"]/g;
  // We'll do a replace with function
  content = content.replace(/(from\s+|import\s+|require\(|import\s+)(['"])([^'"\n]+)(['"])(\))?/g, (full, prefix, q1, impPath, q2, closingParen) => {
    try {
      // only handle local relative imports
      if (!impPath.startsWith('.')) return full;
      const resolved = tryResolveImport(file, impPath);
      if (!resolved) return full;
      // if resolved file was one we renamed, update
      const normResolved = path.normalize(resolved);
      if (oldToNew.has(normResolved)) {
        const newTarget = oldToNew.get(normResolved);
        const preserveExtension = /\.[tj]sx?$/.test(impPath) || /\.json$/.test(impPath);
        const newImport = computeImportPath(file, newTarget, preserveExtension, impPath);
        changed = true;
        console.log('Updating import in', path.relative(repoRoot, file), impPath, '→', newImport);
        return prefix + q1 + newImport + q2 + (closingParen || '');
      }
      return full;
    } catch (err) {
      console.error('Error processing import', impPath, 'in', file, err);
      return full;
    }
  });
  if (changed) fs.writeFileSync(file, content, 'utf8');
}

console.log('Codemod completed. Please run tests and review changes.');
