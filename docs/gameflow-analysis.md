# Gameflow Analysis: GameProvider and Reducer

This document summarizes the examination of the `GameProvider` (located in `src/contexts/game-provider.tsx`) and the game's central reducer (`src/game/reducer.ts`), comparing their implementation against the project's specifications.

## `src/contexts/game-provider.tsx` - The GameProvider

The `GameProvider` React component serves as the central hub for managing the game's state.

**Key aspects:**

*   **State Management:** Utilizes `useReducer` with `applyAction` (from `src/game/reducer.ts`) as its reducer function. The initial state is generated by `initialState()`.
*   **Contexts:** Establishes `GameStateContext` for the immutable game state and `GameDispatchContext` for the `dispatch` function, enabling efficient state and action access throughout the component tree.
*   **Action Validation:** The `dispatch` function is wrapped with a validation layer using `GameActionSchema` and `AnyActionSchema` (from `../../schema/action.schema`). This ensures all dispatched actions conform to a predefined schema, enhancing robustness and error detection. Invalid actions are logged and rejected.
*   **Event Bus Integration:** Integrates with a `globalGameBus` (from `../game/events`) to emit and listen for game-related events, such as turn start/end, tech unlocks, and applied actions, primarily for logging and inter-component communication.
*   **Auto-Simulation:** An `useEffect` hook manages an `autoSim` mode. When active, `requestAnimationFrame` is used to repeatedly call `simulateAdvanceTurn`, facilitating automatic game progression.
*   **`simulateAdvanceTurn`:** This function orchestrates the advancement of a game turn. It emits a `turn:start` event, processes AI player actions by calling `evaluateAI` (from `../game/ai/ai`), dispatches these actions, records AI performance, and finally dispatches an `END_TURN` action.
*   **Immutability:** `Object.freeze(state)` is applied via `useMemo` to ensure the game state remains immutable, aligning with best practices for React and Redux-like patterns.
*   **Initial State:** The `initialState` function sets up the default game state, including `schemaVersion`, `seed`, `turn`, `map` dimensions, an empty `players` array, `techCatalog`, and a `contentExt` (content extension).

## `src/game/reducer.ts` - The Game Reducer

The `applyAction` function in this file is the core reducer responsible for processing `GameAction`s and producing new `GameState`s.

**Key aspects:**

*   **Immer Integration:** Leverages `produceNextState` (suggesting the use of Immer) to allow writing mutable-looking logic within the reducer while guaranteeing immutable state updates.
*   **Action Dispatching:** Employs an `actionReducerMap` to delegate specific action types to dedicated sub-reducers, promoting modularity and organization.
*   **Sub-Reducers:** Integrates several specialized sub-reducers:
    *   `uiReducer`: Manages UI-related state changes (e.g., `SELECT_UNIT`, `OPEN_CITY_PANEL`).
    *   `playerReducer`: Handles player-specific actions (e.g., `SET_RESEARCH`, `CHOOSE_PRODUCTION_ITEM`).
    *   `turnReducer`: Oversees turn progression actions (e.g., `END_TURN`, `AI_PERFORM_ACTIONS`).
    *   `worldReducer`: Deals with world and map-related actions (e.g., `SET_TILE_IMPROVEMENT`, `ADD_UNIT_STATE`).
    *   `lifecycleReducer`: Manages game lifecycle events (e.g., `INIT`, `NEW_GAME`, `AUTO_SIM_TOGGLE`).
*   **`LOAD_STATE` Action:** A dedicated action type that directly replaces the entire game state with its payload, facilitating the loading of saved games. It also emits an `action:applied` event.

## Summary of Gameflow and Spec Adherence:

### Gameflow Overview:

The game's flow is orchestrated by a React `GameProvider` that maintains a central `GameState` using a `useReducer` hook. User and AI actions are dispatched to this reducer, which then intelligently delegates to specialized sub-reducers for state updates. The state is strictly immutable, and all actions undergo validation. An integrated event bus handles logging and inter-component communication. AI players' actions are computed and dispatched during the `simulateAdvanceTurn` function, which can operate automatically in `autoSim` mode.

### Adherence to Specifications:

**Areas Meeting Specifications:**

*   **Centralized State Management:** The `GameProvider` and `useReducer` pattern align perfectly with the `spec-architecture-civweb-lite-core.md`'s emphasis on a single, canonical `GameState` and pure simulation logic.
*   **Immutability:** The use of `Object.freeze` and Immer (via `produceNextState`) ensures state immutability, a core requirement of the specifications.
*   **Action Pattern:** The `GameAction` interface and the dispatch mechanism adhere to the "Command / Action pattern for turn actions" (`PAT-002`) outlined in `spec-architecture-civweb-lite-core.md`.
*   **Deterministic Simulation:** The `simulateAdvanceTurn` function, which incorporates `evaluateAI` and action dispatching, strongly supports the deterministic nature of the game. The inclusion of a `seed` in `initialState` further reinforces this.
*   **AI Integration:** The `evaluateAI` call within `simulateAdvanceTurn` demonstrates that AI is integrated into the turn loop, fulfilling `REQ-004` and `REQ-012`.
*   **Event Logging:** The integration with `globalGameBus` for logging events (e.g., `turn:start`, `turn:end`, `tech:unlocked`) aligns with `REQ-020`.
*   **Action Validation:** The runtime validation of actions using Zod schemas is a robust implementation of `SEC-001` (sanitizing and validating imported JSON, extended to actions).
*   **Modular Reducers:** The use of sub-reducers (`uiReducer`, `playerReducer`, etc.) promotes good modularity, as suggested by `GUD-001` ("Keep simulation pure and stateless (functions returning new state) where feasible").

**Areas Not Yet Meeting (or in Progress) Specifications:**

*   **Detailed UI Interactions:** While `uiReducer` exists and handles actions like `SELECT_UNIT` and `ISSUE_MOVE`, the `ui-interactions.spec.md` explicitly states that these advanced UI interactions (e.g., path preview, combat confirmation, city production queues) are "planned but not yet implemented." The reducer map provides the structural foundation, but the full logic is likely still under development.
*   **Full Game Setup Wizard:** The `INIT` and `NEW_GAME` actions are handled by `lifecycleReducer`, but the comprehensive "Game Setup wizard" described in `game-layout-and-lifecycle.spec.md` (Section 3) would require more extensive UI and state management than is immediately evident from these files alone.
*   **Victory Conditions:** There is no explicit `VICTORY_CHECK` or similar action/reducer mentioned, which aligns with the `game-layout-and-lifecycle.spec.md` stating that victory detection is "not implemented" for the MVP.
*   **Comprehensive AI Logic:** While `evaluateAI` is called, the depth and complexity of AI decision-making (as outlined in `REQ-005` and `GUD-004`) would reside within the `../game/ai/ai.ts` file, which was not part of this specific examination. The `AI_PERFORM_ACTIONS` action indicates the mechanism for AI actions is in place.

This examination confirms that the core architectural foundation for the game is robust and well-aligned with the project's specifications. The areas identified as "not yet implemented" primarily represent feature-level implementations that will build upon this established architecture.